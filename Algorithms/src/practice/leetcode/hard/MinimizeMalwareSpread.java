package practice.leetcode.hard;

import java.util.Arrays;

/**
 * @graph
 *
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1], Output: 0
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2], Output: 0
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2], Output: 1
 *
 * union find all the nodes
 * count the size of each unioned nodes
 * count the number of malware in each unioned nodes
 * for each unioned set, if the only one malware is removed, then the whole set is safe
 * if no such union set exists, remove the minimum index in initial
 */
public class MinimizeMalwareSpread {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] parent = new int[n];
        for (int i = 1; i < n; i++) parent[i] = i;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) union(parent, i, j);
            }
        }
        int[] countSize = new int[n];
        int[] countMal = new int[n];
        for (int i = 0; i < n; i++) countSize[find(parent, i)]++;
        for (int i = 0; i < initial.length; i++) countMal[find(parent, initial[i])]++;
        int res = -1;
        int size = 0;
        Arrays.sort(initial);
        for (int i : initial) {
            int index = find(parent, i);
            if (countMal[index] == 1 && countSize[index] > size) {
                size = countSize[index];
                res = i;
            }
        }
        if (size != 0) return res;
        return initial[0];
    }

    private void union(int[] parent, int i, int j) {
        parent[find(parent, i)] = find(parent, j);
    }

    private int find(int[] a, int x) {
        if (a[x] != x) {
            a[x] = find(a, a[x]);
        }
        return a[x];
    }
}
